nameOverride: ""
fullnameOverride: ""
replicaCount: 1

affinity: {}

auditVolume:
  enabled: false
  mountPath: /audit # defaults to /audit
  capacity: 1Ti # defaults to 1Ti
  attributes:
    resourceGroup: my-azure-resource-group
    storageAccount: my-azure-storage-account
    # containerName: my-azure-container-in-my-azure-storage-account # defaults to release name

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# clusterInternalServiceSuffix allows to override the default ".svc.cluster.local" service address suffix which is used to reach internal services in the cluster.
# Note: It must start with a dot.
# clusterInternalServiceSuffix: .domain.local

# -- cronJob allows you to define a cronJob that mostly bases on the general values.
# Note that since chart version 1.4.0 it is recommended to use preferably extraCronJobs (see readme for more information)
cronJob:
  concurrencyPolicy: Allow
  enabled: false
  env: {}
  failedJobsHistoryLimit: 1
  jobTemplate:
    containers:
      name: ""
    restartPolicy: OnFailure
  name: ""
  schedule: ""
  startingDeadlineSeconds: 60
  successfulJobsHistoryLimit: 1
  suspend: false
  timeZone: Europe/Zurich

# -- deployment is the deployed application
# since this chart allows to also deploy as a CronJob or both, all deployment related values are in this section
deployment:
  enabled: true
  # -- Specify the metadata for the deployment
  metadata:
    # -- Specify the annotations for the deployment
    annotations: {}
    # -- Specify the labels for the deployment
    labels: {}
  # -- Specify how many old ReplicaSets for this Deployment you want to retain.
  revisionHistoryLimit: 3
  # metadata:
  #   labels:
  #     app: backend-service
  #   annotations:
  #     prometheus: "true"
  # initContainers:
  #   - command:
  #       - sh
  #       - -c
  #       - export MY_VARIABLE="some_value" && sleep 1
  #     volumeMounts:
  #       - name: data
  #         mountPath: /opt
  #         mountPathDeployment: /opt/folder
  #         readOnly: true

# env is a flat map of ENV_NAME: $VALUE which will get encapsulated into a ConfigMap and loaded using the envFrom syntax
# It only supports the flat object syntax with key value pairs
env: {}

# envSecrets is a map of ENV_NAME: $SECRET_VALUE which will get encapsulated into a Secret and loaded using the envFrom syntax
envSecrets: {}

# envVars is a list of ENV_NAME: $VALUE which will be added to the pods where the $VALUE supports the same syntax as the native pod spec
# https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
envVars: []

externalSecrets:
  []
  # - keyvaultName: my-keyvault
  #   keyvaultURL: "https://my-keyvault:8989" # private keyvault
  #   identityId: "xxx-xxxxxx-xxx-xxxx"
  #   tenantId: "yyyy-yyy-yyyy-yyyy-yy"
  #   secrets:
  #     - name: golden-secret
  #       type: Opaque
  #       metadata:
  #         labels:
  #           app: my-app
  #           environment: production
  #         annotations:
  #           description: "This secret created by external-secrets.io from kv my-keyvault "
  #       data:
  #         - objectName: my-secret-in-kv-1
  #           key: my-secret-in-kv-1

  #         - objectName: my-secret-in-kv-2
  #           key: my-secret-in-kv-2

# extraEnvCM is a list of existing ConfigMaps to be loaded using the envFrom syntax
extraEnvCM: []

# extraEnvSecrets is a list of existing Secrets to be loaded using the envFrom syntax
extraEnvSecrets: []

# -- extraObjects allows you to add additional Kubernetes objects to the manifest. It is the responsibility of the user to ensure that the objects are valid, that they do not conflict with the existing objects and that they are not containing any sensitive information
extraObjects: []

# -- BETA: Configure additional gateway routes for the chart here.
# More routes can be added by adding a dictionary key like the 'extra-route-1' route.
# In order for this to install, the Gateway [API CRDs](https://gateway-api.sigs.k8s.io/guides/#getting-started-with-gateway-api) must be installed in the cluster.
extraRoutes:
  extra-route-1:
    # -- Enables or disables the route
    enabled: false
    # -- Set the route apiVersion, e.g. gateway.networking.k8s.io/v1 or gateway.networking.k8s.io/v1alpha2
    apiVersion: gateway.networking.k8s.io/v1
    # -- Set the route kind
    # Valid options are GRPCRoute, HTTPRoute, TCPRoute, TLSRoute, UDPRoute
    kind: HTTPRoute
    # -- Set the route annotations
    annotations: {}
    # -- Set the route labels
    labels: {}
    # -- Add hostnames to the route, will be matched against the host header of the request
    hostnames: []
    # -- parentRefs define the parent gateway(s) that the route will be associated with
    parentRefs:
      - name: kong
        namespace: kong-system
        group: gateway.networking.k8s.io
        kind: Gateway
    # -- which match conditions should be applied to the route
    matches:
      - path:
          type: PathPrefix
          value: /
    ## -- Filters define the filters that are applied to requests that match this rule.
    filters: []
    ## -- Additional custom rules that can be added to the route
    additionalRules: []

# -- extraCronJobs allows you to define additional cron jobs besides 'cronJob' itself.
extraCronJobs:
  {}
  # foo:
  #   concurrencyPolicy: Forbid
  #   env:
  #     FOO: BAR
  #   envVars:
  #     - name: BAZ
  #       value: qux
  #   failedJobsHistoryLimit: 3
  #   restartPolicy: Never
  #   schedule: 0 0 1 1 *
  #   startingDeadlineSeconds: 600
  #   successfulJobsHistoryLimit: 3
  #   suspend: false
  #   timeZone: Europe/Zurich
  #   resources:
  #     requests:
  #       cpu: 100m
  #       memory: 100Mi
  #     limits:
  #       cpu: 200m
  #       memory: 200Mi

hooks:
  migration:
    enabled: false
    # name: "" defaults to db-migration
    command: ""
    # -- Optional resource requirements for the migration job
    # If not set, will use the global resources configuration
    # resources:
    #   requests:
    #     cpu: 100m
    #     memory: 128Mi
    #   limits:
    #     memory: 128Mi
    # initContainers:
    #   - command:
    #       - sh
    #       - -c
    #       - export MY_VARIABLE="some_value" && sleep 1
    #     volumeMounts:
    #       - name: data
    #         mountPath: /opt
    #         mountPathJob: /opt/folder
    #         readOnly: true

# -- networkPolicy allows you to define network policies for the deployed pods
# Network policies are used to control traffic flow to and from pods
networkPolicy:
  # -- Enable or disable network policy creation
  enabled: false
  # -- Network policy flavor - "kubernetes" for standard NetworkPolicy or "cilium" for CiliumNetworkPolicy
  flavor: kubernetes
  # -- Policy types to apply (Ingress, Egress, or both)
  # policyTypes:
  #   - Ingress
  #   - Egress
  # -- Description of the network policy (Cilium only)
  # description: "Network policy for backend service"
  # -- Enable default deny for all traffic (Cilium only)
  # enableDefaultDeny:
  #   ingress: true
  #   egress: true
  # -- Labels to be applied to the network policy spec (Cilium only)
  # labels:
  #   component: backend
  #   tier: application
  # -- Labels to be applied to the network policy spec (Cilium only)
  # ciliumPolicylabels:
  #   - key: component
  #     value: backend
  #   - key: tier
  #     value: application
  # -- Ingress rules configuration
  ingress:
    # -- Default ingress rules applied to all pods
    # Allow ingress from pods in the same namespace
    - from:
        - podSelector: {}
    # Example ingress rules:
    # - from:
    #     - namespaceSelector:
    #         matchLabels:
    #           name: monitoring
    #   ports:
    #     - protocol: TCP
    #       port: 8080
    # - from:
    #     - podSelector:
    #         matchLabels:
    #           app: frontend
    #   ports:
    #     - protocol: TCP
    #       port: 8080
  # -- Ingress deny rules configuration (Cilium only)
  # ingressDeny:
  #   - from:
  #       - podSelector:
  #           matchLabels:
  #             app: untrusted
  # -- Egress rules configuration
  egress:
    # -- Default egress rules applied to all pods
    # Allow egress to pods in the same namespace
    - to:
        - podSelector: {}
    # Allow DNS resolution
    - to: []
      ports:
        - protocol: UDP
          port: 53
    # Example egress rules:
    # - to:
    #     - namespaceSelector:
    #         matchLabels:
    #           name: database
    #   ports:
    #     - protocol: TCP
    #       port: 5432
    # - to: []
    #   ports:
    #     - protocol: TCP
    #       port: 443
    #     - protocol: TCP
    #       port: 80
  # -- Egress deny rules configuration (Cilium only)
  # egressDeny:
  #   - to:
  #       - namespaceSelector:
  #           matchLabels:
  #             name: restricted
  # -- Additional labels to add to the network policy
  labels: {}
  # -- Additional annotations to add to the network policy
  annotations: {}

# -- The image to use for this specific deployment and its cron jobs
image:
  # -- Repository, where the Unique service image is pulled from
  # - for Unique internal deployments, these is the internal release repository
  # - for client deployments, this will refer to the client's repository where the images have been mirrored too
  # Note that it is bad practice and not advised to directly pull from Uniques release repository
  # Read in the readme on why the helm chart comes bundled with the unique-ag/chart-testing-service image
  repository: "ghcr.io/unique-ag/chart-testing-service"
  # -- tag, most often will refer one of the latest release of the Unique service
  # Read in the readme on why the helm chart comes bundled with the unique-ag/chart-testing-service image
  tag: "1.0.4"
  # -- pullPolicy, Unique recommends to never use 'Always'
  pullPolicy: IfNotPresent

imagePullSecrets: []

# -- keda allows you to enable KEDA for the chart
# `keda` and are mutually exclusive.
keda:
  # -- enable KEDA/ScaledObject for the chart
  enabled: false
  # -- pause the ScaledObject
  paused: false
  # -- extra annotations for the ScaledObject
  extraAnnotations: {}
  # -- polling interval for the ScaledObject
  pollingInterval: 30
  # -- cooldown period for the ScaledObject
  cooldownPeriod: 300
  # -- idle replica count for the ScaledObject
  # Due to limitations in HPA controller, the only supported value is 0.
  # See: https://keda.sh/docs/2.14/concepts/scaling-deployments/#idlereplicacount
  # When not set, maintains at least minReplicaCount replicas even when idle.
  # idleReplicaCount: 0
  # -- min replica count for the ScaledObject
  minReplicaCount: 1
  # -- max replica count for the ScaledObject
  maxReplicaCount: 4
  # -- triggers for the ScaledObject
  # You can specify multiple triggers for the ScaledObject as outlined in https://keda.sh/docs/2.14/scalers/
  # The key names are arbitrary and used only for overlay purposes
  # Note that when disabling/overriding a trigger with `null` to unset it, helm will issue a warning as its cautious about merging types.
  # For that case, the warning can be ignored.
  triggers:
    {}
    # # -- rabbitmq example
    # rabbitmq-trigger:
    #   type: rabbitmq
    #   metadata:
    #     protocol: amqp
    #     queueName: testqueue
    #     mode: QueueLength
    #     value: "20"
    #   # -- authenticationRef for the ScaledObject
    #   # Note that the TriggerAuthentication resource must be created separately
    #   authenticationRef:
    #     name: keda-trigger-auth-rabbitmq-conn
    # # -- cron example
    # cron-trigger:
    #   type: cron
    #   metadata:
    #     # -- The acceptable values would be a value from the IANA Time Zone Database.
    #     timezone: Europe/Zurich
    #     start: 0 6 * * *
    #     end: 0 20 * * *
    #     # -- desired replicas for the ScaledObject
    #     desiredReplicas: "10"

# -- PodDisruptionBudget configuration
# Note: If both maxUnavailable and minAvailable are set, minAvailable takes precedence
pdb:
  # -- Maximum number of pods that can be unavailable during a disruption
  # Can be either a percentage (e.g., "30%") or an absolute number (e.g., "2")
  maxUnavailable: 30%
  # -- Minimum number of pods that must be available during a disruption
  # Can be either a percentage (e.g., "50%") or an absolute number (e.g., "1")
  # minAvailable: 1

# -- Define additional pod annotations for all the pods
podAnnotations: {}

# -- Define additional pod labels for all the pods
podLabels:
  logging.unique.app/format: "pino-json"

# -- PodSecurityContext for the pod(s)
podSecurityContext:
  # -- seccompProfile, controls the seccomp profile for the container, defaults to 'RuntimeDefault'
  seccompProfile:
    ## -- type, the type of seccomp profile to use, defaults to 'RuntimeDefault'
    type: RuntimeDefault

# -- the ports section allows specify ports used for different purposes
ports:
  # -- application port, this is the port that the deployed Unique application listens on
  # ℹ You may not be able to use ports below 1024 as non-root user which is the default securityContext of this chart
  # If you need to use a port below 1024, you can override the securityContext of the deployment (discouraged) or get the `NET_BIND_SERVICE` capability added to the container (also discouraged but preferred if absolutely needed, at your own risk/liability)
  application: 8080
  # -- optional metrics port, does not default and is disabled when not set. Basic uses cases use the application port.
  # metrics: 8081
  # -- service port, this is the port that the service will be exposed on
  service: 80

probes:
  enabled: true
  liveness:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 6
  readiness:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 6
  startup:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    failureThreshold: 30
    periodSeconds: 10

nodeSelector: {}

prometheus:
  enabled: true
  # -- Additional custom alert rules that will be rendered using the alerts-custom.yaml template
  # The alerts are rendered directly using toYaml, giving you complete control over the alert structure
  # Labels from defaultAlerts.additionalLabels are automatically merged into each alert's labels
  # additionalAlerts:
  #   HighErrorRate:
  #     alert: HighErrorRate
  #     expr: rate(http_requests_total{status=~"5.."}[5m]) / rate(http_requests_total[5m]) * 100 > 5
  #     for: 5m
  #     labels:
  #       severity: critical
  #       alertGroup: application
  #       service: "{{ $labels.service }}"
  #     annotations:
  #       summary: "High error rate detected"
  #       description: "Error rate is above 5% for more than 5 minutes"
  #       runbook_url: "https://example.com/runbooks/high-error-rate"
  #       dashboard: "https://grafana.example.com/d/app-dashboard"
  #   DatabaseConnectionsHigh:
  #     alert: DatabaseConnectionsHigh
  #     expr: pg_stat_database_numbackends > 80
  #     for: 10m
  #     labels:
  #       severity: warning
  #       alertGroup: database
  #     annotations:
  #       summary: "Database connections are high"
  #       description: "Database has {{ $value }} active connections"
  # -- defaultAlerts allows you to enable predefined alert groups for monitoring
  defaultAlerts:
    # -- Enable ArgoCD application health and condition alerts
    argocd:
      enabled: true
      # -- ArgoCD application name override (defaults to release name if not set)
      # applicationName: ""
    # -- Enable Kubernetes application alerts (restarts, crashlooping, etc.)
    kubernetesApplication:
      enabled: true
      # -- Disable specific alerts by setting them to true
      disabled:
        {}
        # KubePodCrashLooping: false
        # KubePodNotReady: false
        # KubeDeploymentGenerationMismatch: false
        # KubeDeploymentReplicasMismatch: false
        # KubeDeploymentRolloutStuck: false
        # KubeStatefulSetReplicasMismatch: false
        # KubeStatefulSetGenerationMismatch: false
        # KubeStatefulSetUpdateNotRolledOut: false
        # KubeDaemonSetRolloutStuck: false
        # KubeContainerWaiting: false
        # KubeDaemonSetNotScheduled: false
        # KubeDaemonSetMisScheduled: false
        # KubePodFrequentRestarts: false
        # KubeJobNotCompleted: false
        # KubeJobFailed: false
        # KubeHpaReplicasMismatch: false
        # KubeHpaMaxedOut: false
        # KubePersistentVolumeClaimPending: false
        # KubePdbNotEnoughHealthyPods: false
      # -- Override alert rules with custom values (for duration, severity, etc.)
      customRules:
        {}
        # KubePodCrashLooping:
        #   for: "10m"
        #   severity: "critical"
        # KubePodNotReady:
        #   for: "20m"
        # KubeContainerWaiting:
        #   for: "30m"
        # KubeJobFailed:
        #   for: "5m"
    # -- Enable Kubernetes resource alerts (CPU, memory, disk, network, etc.)
    kubernetesResources:
      enabled: true
      # -- Disable specific alerts by setting them to true
      disabled:
        {}
        # KubernetesPodHighCPUUsage: false
        # KubernetesPodHighMemoryUsage: false
        # KubernetesPodNearMemoryLimit: false
        # KubernetesPodThrottled: false
        # KubernetesPersistentVolumeHighUsage: false
        # KubernetesPersistentVolumeNearFull: false
        # KubernetesContainerOOMKilled: false
        # KubernetesPodMissingResourceLimits: false
        # KubernetesHPAScalingEvent: false
        # KubernetesHPAMaxReplicasReached: false
      # -- Override alert rules with custom values (for duration, severity, etc.)
      customRules:
        {}
        # KubernetesPodHighCPUUsage:
        #   for: "15m"
        #   severity: "critical"
        # KubernetesPodNearMemoryLimit:
        #   for: "2m"
        # KubernetesContainerOOMKilled:
        #   for: "1m"
    # -- Additional labels to add to all default alerts
    additionalLabels:
      {}
      # environment: production
      # team: backend

resources: {}

rollingUpdate:
  maxSurge: 1
  maxUnavailable: 0

# -- routes is a special object designed for Unique services. It abstracts a lot of complexity and allows for a simple configuration of routes.
# ⚠️ Unique defaults to Kong as its API Gateway (the middlewares especially), and the routes object is designed to work with Kong (but might work with other implementations as well). If you are using a different API Gateway, you will need to change the `gateway details` or use `extraRoutes`.
# Refer to [`ci/routes-values.yaml`](https://github.com/Unique-AG/helm-charts/blob/main/charts/backend-service/ci/routes-values.yaml) to see a full example of how to configure routes.
# Currently, routes must be explicitly enabled until the Unique Kong migration is complete.
routes:
  # - hostname of the route, will be matched against the host header of the request
  # currently defaults to one, if ever more are needed open an issue, `extraHostNames` will be added, supports templating
  hostname: chart-testing-service.example.com
  # -- gateway to use
  gateway:
    # -- name of the gateway
    # @default -- kong
    name: kong
    # -- namespace of the gateway
    # @default -- system
    namespace: system
  # -- pathPrefix allows setting the default prefix (fullname) for all paths
  # @default -- defaults to /fullname of the service
  pathPrefix: ""
  paths:
    default:
      enabled: true
      # -- explicitly list paths to block
      blockList:
        - /metrics
      extraAnnotations:
        []
        # konghq.com/request-buffering: "false"
        # konghq.com/read-timeout: "120s"
    versioned:
      enabled: false
      # -- users wishing to not call their versioned API 'public' can override the path
      # ⚠️ Customizing this value requires also changing the default url in multiple places including all SDK or integration use cases
      # @default -- the chart will default to 'public' to stay backward compatible
      pathOverride: /public
      extraAnnotations:
        []
        # konghq.com/request-buffering: "false"
    scoped:
      enabled: false
      # -- users wishing to not call their scoped API 'scoped' can override the path
      # ⚠️ Customizing this value requires also changing the default url in multiple places including all web-apps
      # @default -- the chart will default to 'scoped' to stay backward compatible
      pathOverride: /scoped
      # -- explicitly list of exact path matches
      # Only exact path matches are supported to ensure strict security
      # will be rendered to: `/{scoped|pathOverride}/{entry}`
      allowList:
        - /upload
      extraAnnotations: []
      #   konghq.com/request-buffering: "false"
    # -- `/probe` is unauthorized and its sole purpose is to expose a health check endpoint for availability monitoring
    # Maps to version neutral `/probe` endpoint all Unique services expose
    probe:
      enabled: false
      # -- path to the probe endpoint
      probePath: /probe
      extraAnnotations:
        []
        # konghq.com/strip-path: "true"

# !!! usePodIdentity will be deprecated in the future please use useVMManagedIdentity with the clientID
# .Values.secretProvider lets you mount secrets from Azure Key Vault into the pod
# Note that 'vault-1' is the literal vault name from azure
# The line format is 'make <ENV>: from <KEY_VAULT_SECRET_NAME>'
# The conversion from - to _ is done automatically
secretProvider: {}
# Example
# secretProvider:
#   tenantId: 99330c76-81d2-460e-861e-35af8e2a4266
#   aadPodIdBinding: binding-21 # optional, defaults to 'keyvault'
#   useVMManagedIdentity: "true" # optional, if not present usePodIdentity is set to "true" useVMManagedIdentity to "false"
#   userAssignedIdentityID: "xx-pls-provide-client-id-xx"   # Should not be empty if useVMManagedIdentity is present and has the value "true"
#   vaults:
#     vault-name-1:
#       MY_ENV_VARIABLE_1: keyvault-secret-name-a
#     vault-name-2:
#       MY_ENV_VARIABLE_2: keyvault-secret-name-b

# -- securityContext for the container(s)
securityContext:
  # -- AllowPrivilegeEscalation, controls if the container can gain more privileges than its parent process, defaults to 'false'
  allowPrivilegeEscalation: false
  # -- readOnlyRootFilesystem, controls if the container has a read-only root filesystem, defaults to 'true'
  readOnlyRootFilesystem: true
  # -- runAsNonRoot, controls if the container must run as a non-root user, defaults to 'true'
  runAsNonRoot: true
  # -- runAsUser, controls the user ID that runs the container, defaults to '1000'
  runAsUser: 1000
  # -- capabilities section controls the Linux capabilities for the container
  capabilities:
    drop:
      - ALL

service:
  enabled: true
  type: ClusterIP
  port: 80
  # -- extraLabels allows you to add additional labels to the service e.g. {"foo": "bar"}
  extraLabels: {}
  annotations: {}

serviceAccount:
  enabled: false
  annotations: {}
  # name: ""
  workloadIdentity: {}

tolerations: []

volumeMounts: []

volumes: []
